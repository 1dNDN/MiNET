using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Jose;
using log4net;
using Microsoft.AspNet.Identity;
using Microsoft.IO;
using MiNET.Net;
using MiNET.Plugins;
using MiNET.Security;
using MiNET.Utils;

namespace MiNET
{
	public class MiNetServer
	{
		private static readonly ILog Log = LogManager.GetLogger(typeof (MiNetServer));

		private const int DefaultPort = 19132;

		public IPEndPoint Endpoint { get; private set; }
		private UdpClient _listener;
		private ConcurrentDictionary<IPEndPoint, PlayerNetworkSession> _playerSessions = new ConcurrentDictionary<IPEndPoint, PlayerNetworkSession>();

		public bool ForwardAllPlayers { get; set; }
		public IPEndPoint ForwardTarget { get; set; }

		public MotdProvider MotdProvider { get; set; }

		public bool IsSecurityEnabled { get; private set; }
		public UserManager<User> UserManager { get; set; }
		public RoleManager<Role> RoleManager { get; set; }

		public static RecyclableMemoryStreamManager MemoryStreamManager { get; set; } = new RecyclableMemoryStreamManager();

		public LevelManager LevelManager { get; set; }
		public PlayerFactory PlayerFactory { get; set; }
		public GreylistManager GreylistManager { get; set; }

		public PluginManager PluginManager { get; set; }
		public SessionManager SessionManager { get; set; }

		private Timer _internalPingTimer;
		private Timer _ackTimer;
		private Timer _cleanerTimer;

		public int InacvitityTimeout { get; private set; }

		public ServerInfo ServerInfo { get; set; }

		public MiNetServer()
		{
		}

		public MiNetServer(IPEndPoint endpoint)
		{
			Endpoint = endpoint;
		}

		public static bool IsRunningOnMono()
		{
			return Type.GetType("Mono.Runtime") != null;
		}

		public bool StartServer()
		{
			//string t = "eyJhbGciOiJFUzM4NCIsIng1dSI6Ik1IWXdFQVlIS29aSXpqMENBUVlGSzRFRUFDSURZZ0FFREVLbmVxRXZjcVVxcUZNTTFITTFBNHpXakpDK0k4WSthS3pHNWRsKzZ3Tk9ISFE0Tm1HMlBFWFJKWWh1anlvZEZIK3dPMGRFcjRHTTFXb2FXb2c4eHNZUTZtUUpBQzBlVnBCTTk2c3BVQjFlTU41NitCd2xKNEgzUXg0VEF2QXMifQo,.eyJDbGllbnRSYW5kb21JZCI6MTM2NTg2NDYwOCwiU2VydmVyQWRkcmVzcyI6IjE5Mi4xNjguMS41NjoxOTEzMiIsIlNraW5EYXRhIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGxtVWYvNVpsSC8rV05QLy9sbVVmLzVabEgvK1dOUC8vbG1VZi81WTAvLzlpQU12L1lnREwvMklBeS85aUFNdi9ZZ0RMLzJJQXkvOWlBTXYvWWdETC9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNVkwLy8rV1pSLy9salQvLzVabEgvK1daUi8vY2t6ei81WmxILytpZFRQL1lnREwvMklBeS82cUpYditxaVY3L3FvbGUvNnFKWHYvWWdETC8ySUF5L3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPV1pSLy9ja3p6LzZKMU0vK1daUi8vbGpULy8zSk04LytXTlAvL2xtVWYvMklBeS82cUpYditjZTFEL25IdFEvNXg3VVArY2UxRC9xb2xlLzlpQU12OEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURsalQvLzNKTTgvK2lkVFAvbG1VZi81WmxILytXWlIvL2xqVC8vM0pNOC85aUFNditxaVY3L25IdFEvNXg3VVArY2UxRC9uSHRRLzZxSlh2L1lnREwvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTVZMC8vK1dOUC8vb25Vei81WTAvLytXWlIvL2xqVC8vNkoxTS85eVRQUC9meHFQL3FvbGUvNXg3VVArY2UxRC9uSHRRLzV4N1VQK3FpVjcvMklBeS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT1daUi8vbGpULy81WmxILytXTlAvL2NrenovNVpsSC8raWRUUC9vblV6LzM4YWovNnFKWHYrY2UxRC9uSHRRLzV4N1VQK2NlMUQvcW9sZS85aUFNdjhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEY2t6ei81WTAvLytXTlAvL2xtVWYvNVpsSC8rV1pSLy9salQvLzZKMU0vOS9Hby8rcWlWNy9xb2xlLzZxSlh2K3FpVjcvcW9sZS82cUpYdi9ZZ0RML0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE2SjFNLytXWlIvL2xqVC8vNkoxTS8raWRUUC9salQvLzZKMU0vOXlUUFAvZnhxUC8zOGFqLzkvR28vL2Z4cVAvMzhhai85L0dvLy9meHFQLzM4YWovd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGxtVWYvNVkwLy8raWRUUC9sbVVmLzZKMU0vK2lkVFAvb25Vei81WTAvLytXWlIvL2xqVC8vNVpsSC8rV05QLy9salQvLzVabEgvK1dOUC8vbG1VZi81WmxILytXTlAvL2xtVWYvNVkwLy8rV1pSLy9salQvLzZKMU0vK1daUi8vbGpULy81WmxILytXTlAvL2xtVWYvNVkwLy8rV1pSLy9vblV6LzVZMC8vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNVkwLy8rV1pSLy9sbVVmLzVZMC8vK1daUi8vbGpULy81WTAvLytXWlIvL2xqVC8vNVpsSC8rV05QLy9sbVVmLzNKTTgvK1daUi8vbG1VZi81WTAvLytXWlIvL29uVXovNkoxTS8raWRUUC9salQvLzVabEgvK1dOUC8vbG1VZi82SjFNLytpZFRQL2xtVWYvNVkwLy8raWRUUC9vblV6LzVZMC8vK1daUi84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPaWRUUC9vblV6LzVZMC8vK1daUi8vbGpULy81WmxILytpZFRQL2xtVWYvNVpsSC8rV05QLy9sbVVmLzNKTTgvK3ZUcy8vcjA3UC81WmxILytXTlAvL29uVXovNVkwLy8rV05QLy9salQvLzZKMU0vK1daUi8vbGpULy82SjFNLytpZFRQL29uVXovNVkwLy8raWRUUC9sbVVmLzZKMU0vK1dOUC8vbG1VZi9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURsbVVmLzNKTTgvK1daUi8vbG1VZi82SjFNLzl5VFBQL2NrenovNVpsSC85eVRQUC9ja3p6LzNKTTgvK3ZUcy8veTJyci81TXVwLytUTHFmL2xtVWYvNVpsSC8rV1pSLy9ja3p6LzVabEgvK1dOUC8vb25Vei82SjFNLytXWlIvL2xqVC8vNkoxTS8rV05QLy9vblV6LzVabEgvK1dOUC8vbG1VZi81WTAvL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTNKTTgvK1daUi8vbG1VZi81WmxILzl5VFBQL3IwN1AvNjlPei85eVRQUC9reTZuLysvdjcveU5pSlAveTJyci84dDNDL3lOaUpQLzcrL3YvNU11cC85eVRQUC9salQvLzVabEgvK1daUi8vbG1VZi81WTAvLytXWlIvL2xqVC8vNVpsSC8rV05QLy9sbVVmLzVabEgvK2lkVFAvbG1VZi81WmxILytpZFRQOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTnlUUFAvbGpULy82SjFNLzl5VFBQL3IwN1AvOHQzQy8vTGF1di95MnJyLzd0YTIvKy9adS8veTJyci84dDNDLy9MYXV2L3kyNzMvN3RlNS8vTGF1di9yMDdQLzNKTTgvK1daUi8vbGpULy81WmxILytXWlIvL29uVXovNVkwLy8rV05QLy9vblV6LzVabEgvK1dOUC8vbGpULy82SjFNLytXWlIvL2xtVWYvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEbGpULy81WmxILytpZFRQL2xtVWYvNjlPei8vTGF1di95M2NMLzh0M0MvL0xhdXYveTNjTC84dHE2LysrN3NmL3Z1N0gvOHRxNi8vTGF1di9yMDdQLzh0M0MvK3ZUcy8vY2t6ei81WTAvLytXWlIvL2xqVC8vNVpsSC8raWRUUC9salQvLzVZMC8vK1dOUC8vbG1VZi82SjFNLytXWlIvL2xtVWYvNVkwLy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE1WmxILytXTlAvL2xtVWYvNjlPei8rdlRzLy95M2NMLzh0cTYvL0xhdXYveTJyci84dHE2Ly9MZHd2L3kycnIvOHRxNi8vTGR3di95M2NMLzh0cTYvK3ZUcy8vY2t6ei81WTAvLytXWlIvL2xtVWYvNVkwLy8rV1pSLy9salQvLzVabEgvK1dOUC8vb25Vei81WmxILytXWlIvL2NrenovNVkwLy8raWRUUDhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJrUVN6L1pFRXMvMlJCTFA5a1FTei9LQ2dvL3lnb0tQOG9LQ2ovS0Nnby93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZXJWMy80YUhZZi9ZZ0RMLzJJQXkvOWlBTXYvWWdETC82SjFNLytXWlIvOW9SVEQvYUVVdy8yaEZNUDlvUlREL2FFVXcvMmhGTVA5b1JURC9hRVV3L3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFlcTkzLzNxdmQvOTZyM2YvMkxxVS8rdlRzLy9ZdXBUL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVpFRXMvMlJCTFA5a1FTei9aRUVzL3lnb0tQOG9LQ2ovS0Nnby95Z29LUDhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIcTFkLytHaDJIL2hvZGgvNGFIWWYrR2gySC8ySUF5LytXWlIvL29uVXovYUVVdy8yaEZNUDlvUlREL2FFVXcvMmhGTVA5b1JURC9hRVV3LzJoRk1QOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhxdmQvOTZ0WGYvZXE5My85aTZsUC9yMDdQLzJMcVUvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1JCTFA5a1FTei9aRUVzLzJSQkxQOG9LQ2ovS0Nnby95Z29LUDhvS0NqL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUI2dFhmL2hvZGgvNGFIWWYvZnhxUC8zOGFqLzRhSFlmL2xtVWYvNkoxTS8yaEZNUDlvUlREL2FFVXcvMmhGTVA5b1JURC9hRVV3LzJoRk1QOW9SVEQvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjZyM2YvZXJWMy8zcXZkLy9yMDdQLzJMcVUvK3ZUcy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCa1FTei9aRUVzLzJSQkxQOWtRU3ovS0Nnby95Z29LUDhvS0NqL0tDZ28vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWVyVjMvNGFIWWYvcjA3UC84dHE2Ly9MYXV2L2xtVWYvNVpsSC8rV05QLzlvUlREL2FFVXcvMmhGTVA5b1JURC9hRVV3LzJoRk1QOW9SVEQvYUVVdy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZXE5My8zcXZkLzk2cjNmLzY5T3ovOWk2bFAvcjA3UC9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUI2cjNmL2VyVjMvM3ExZC85NnIzZi9hRVV3LzNsVlBmK0FXa0QvYlVvei8yaEZNUDlrUVN6L2FFVXcvMlJCTFArTXZvci9qTDZLLzMyeWV2OTlzbnIvZXJWMy8zcTFkLzk2dFhmL2VxOTMvNHkraXYrR2gySC82OU96Ly9MYXV2L3kycnIvNkoxTS8raWRUUC9salQvLzZKMU0vK2lkVFAvbG1VZi82SjFNLytpZFRQL29uVXovNVpsSC8rV05QLy9sbVVmLzVabEgvNEcxZi8rTHVvai9lcTkzLzNxMWQvOTZyM2YvZXE5My80eStpditMdW9qL2ZiSjYvM3F2ZC85NnRYZi9lclYzLzNxdmQvK0x1b2ovakw2Sy80dTZpUDhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVpFRXMvM3F2ZC85NnIzZi9hRVV3LzNKT052OTVWVDMvZVZVOS8yaEZNUDlrUVN6L2FFVXcvMmhGTVA5a1FTei9iMHcxLzRCYVFQK0FXa0QvY2s0Mi8zcTFkLzk2dFhmL2VxOTMvM3F2ZC8rTXZvci9pb3RtLyt2VHMvL3kycnIvOHRxNi8vTGF1di9sbVVmLzZKMU0vK1daUi8vbG1VZi9lcTkzLzNxdmQvL2xtVWYvNVkwLy8rV05QLy9sbVVmL2diVi8vNEcxZi8rTHVvai9pN3FJLzNxdmQvOTZyM2YvZXE5My8zcTFkLytMdW9qL2ZiSjYvNHkraXY5NnRYZi9lclYzLzNxdmQvOTZyM2YvaTdxSS80dTZpUCtNdm9yL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1JCTFA5b1JURC9aRUVzLzJoRk1QOXZURFgvZ0ZwQS8yaEZNUDl5VGpiL1pFRXMvMmhGTVA5a1FTei9hRVV3LzI5TU5mK0FXa0QvZVZVOS8zSk9Odjk2cjNmL2VyVjMvM3F2ZC85NnIzZi9qTDZLLzMyeWV2K01qV2ovNjlPei8rdlRzLy9salQvLzVabEgvK2lkVFA5NnIzZi9lcTkzLzNxdmQvOTZ0WGYvZ2JWLy80RzFmLytCdFgvL2diVi8vNHkraXYrTHVvai9pN3FJLzR1NmlQOTZyM2YvZXJWMy8zcTFkLzk2dFhmL2k3cUkvNHkraXYrTHVvai9lcTkzLzNxMWQvOTZ0WGYvZXE5My80eStpditMdW9qL2pMNksvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCa1FTei9aRUVzLzJSQkxQOW9SVEQvYUVVdy8yaEZNUDk1VlQzL2NrNDIvMlJCTFA5b1JURC9aRUVzLzJoRk1QOXZURFgvZ0ZwQS8zbFZQZjl5VGpiL2VxOTMvM3ExZC85NnIzZi9lcTkzLzNldmRmK012b3Ivakw2Sy80eU5hUCtNaldqLzVabEgvK2lkVFA5OXNuci9lclYzLzNxMWQvOTZyM2YvZXJWMy80eStpditMdW9qL2pMNksvNHU2aVArTHVvai9pN3FJLzMyeWV2K0x1b2ovZ0lKYS80ZUpZditIaVdML2dJSmEvNGFIWWYrUGtHdi9ob2RoLzRDQ1d2K0hpV0wvaDRsaS80Q0NXditHaDJIL2o1QnIvNGFIWWY4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaRUVzLzJSQkxQOWtRU3ovWkVFcy8yOU1OZitHWGtiL2hsNUcvMjlNTmY5a1FTei9aRUVzLzJSQkxQOWtRU3ovYUVVdy8yaEZNUDlvUlREL2FFVXcvM3F2ZC85NnRYZi9lclYzLzNxMWQvOTNyM1gvakw2Sy80eStpdjk5c25yL2pMNksvK2lkVFA5OXRIci9pN3FJLzNxdmQvOTZyM2YvZXE5My8zcTFkLytNdm9yL2k3cUkvNHkraXYrTHVvai9pN3FJLzR5K2l2K012b3Ivakw2Sy8rVEpxUC9reWFqLzVNbW8vK1RKcVAvcjA3UC82OU96Lyt2VHMvL2t5YWovNU1tby8rVEpxUC9reWFqLzY5T3ovK3ZUcy8vcjA3UC9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURzN08vODdPenYvT3pzNy8yUkJMUDlvUlREL2VGUTgvM2hVUFA5b1JURC9aRUVzL3pzN08vODdPenYvT3pzNy8wWkdSdjlHUmtiL1JrWkcvMFpHUnY5NnIzZi9lclYzLzNxdmQvOTZ0WGYvZmJKNi80eStpditMdW9qL2pMNksvNHU2aVArTXZvci9pN3FJLzR1NmlQOTZyM2YvZXE5My8zcXZkLzk2cjNmL2k3cUkvMzJ5ZXYrTXZvci9pN3FJLzR1NmlQK012b3IvaTdxSS80eStpdi9reWFqLzVNbW8vK3ZUcy8vcjA3UC84dHE2Ly9MYXV2L3IwN1AvNjlPei8rdlRzLy9reWFqLzY5T3ovL0xhdXYvcjA3UC84dHE2L3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkpTVW4vU1VsSi8wbEpTZjg3T3p2L1dscGEvMTFkWGY5ZFhWMy9XbHBhL3pzN08vOUpTVW4vU1VsSi8wbEpTZjlOVFUzL1YxZFgvMWRYVi85TlRVMy9lcTkzLzNxMWQvOTZyM2YvZXJWMy80eStpditNdm9yL2ZiSjYvNHkraXYrTHVvai9qTDZLLzR1NmlQK012b3IvZXE5My8zcTFkLzk2cjNmL2VxOTMvNHU2aVArTXZvci9qTDZLLzR1NmlQK012b3IvZmJKNi80eStpditNdm9yLzVNbW8vK3ZUcy8vcjA3UC82OU96Ly9MYXV2L3kycnIvNmRDdi8rdlRzLy9zMUxqLzVNdXEvK3pVdVAveTJyci84dHE2Ly9MZHd2OEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU1VsSi8wbEpTZjlKU1VuL1NVbEovMkZoWWY5cmEydi9hMnRyLzJGaFlmOUpTVW4vU1VsSi8wbEpTZjlKU1VuL1RVMU4vMWRYVi85WFYxZi9UVTFOLzNxMWQvOTZ0WGYvZXJWMy8zcTFkLytNdm9yL2pMNksvM2V2ZGYrTXZvci9mYko2LzR5K2l2K012b3Ivakw2Sy8zcXZkLzk2dFhmL2VyVjMvM3ExZC8rTXZvci9qTDZLLzR5K2l2OTlzbnIvakw2Sy8zMnllditNdm9yL2pMNksvK3pVdVAvcjA3UC83TlM0Lyt2VHMvL3AwYlAvOHRxNi8vTGF1di92MmIzLzdOUzQvK1hMcmYvdjJyLy84dHE2Ly9MYXV2L3AwYlAvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFbEpTZjlKU1VuL096czcvMGxKU2Y5aFlXSC9hMnRyLzJ0cmEvOWhZV0gvU1VsSi96czdPLzlKU1VuL1NVbEovMDFOVGY5WFYxZi9WMWRYLzAxTlRmOFlPQmIvR2o4Wi94ZzRGdjhhUHhuL1Q0Qk0vNHkraXY5M3IzWC9qTDZLLzNldmRmK012b3Ivakw2Sy8wK0FUUDhhUHhuL0dqOFoveGc0RnY4YVB4bi9UNEJNLzR5K2l2K012b3IvZDdCMC80eStpdjkzcjNYL2pMNksvMCtBVFAvczFMai83TlM0Lyt6VXVQL3MxTGovNmRHei8vTGR3di95M2NMLzdOUzQvKy9hdi8vczFMai83TlM0Ly9MZHd2L3kzY0wvOHQzQy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJOVFUzL1RVMU4vMUpTVXY4N096di9XbHBhLzJOalkvOWpZMlAvV2xwYS96czdPLzlTVWxML1RVMU4vMDFOVGY5S1Nrci9VRkJRLzFCUVVQOUtTa3IvZXJWMy8zcXZkLzk2dFhmL2VxOTMveGc0RnY4WU9CYi9HRGdXL3hvL0dmOGFQeG4vR0RnVy94ZzRGdjhhUHhuL2VxOTMvM3F2ZC85NnRYZi9lclYzL3hvL0dmOFlPQmIvR0RnVy94by9HZjhhUHhuL0dEZ1cveG8vR2Y4YVB4bi83TlM0Lyt6VXVQL3Yyci8vNzlxLy8vTGR3di95M2NMLzh0L0kvK3pVdVAvdjJyLy83TlM0Lyt6VXVQL3kzOGovOHQzQy8rclV1UDhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVRVMU4vMDFOVGY5U1VsTC9YRnhjLzJGaFlmOXJhMnYvYTJ0ci8yRmhZZjljWEZ6L1VsSlMvMDFOVGY5TlRVMy9Ta3BLLzFCUVVQOVFVRkQvU2twSy8zcTFkLzk2cjNmL2VyVjMvM3F2ZC8rTHVvai9qTDZLLzR1NmlQK012b3IvZmJKNi80dTZpUCtMdW9qL2pMNksvM3F2ZC85NnIzZi9lclYzLzNxdmQvK0x1b2ovakw2Sy80eStpdjk5c25yL2pMNksvNHU2aVArTHVvai9qTDZLLysvYXYvL3Yyci8vN05TNC8rL2F2Ly95MzhqLzh0L0kvL0xkd3YvdjJyLy83OXEvLysvYXYvL3MxTGovOHQvSS8vTGR3di95M2NML0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDgvUC84L1B6Ly9QejgvLzF4Y1hQOWpZMlAvY0hCdy8zQndjUDlqWTJQL1hGeGMvejgvUC84L1B6Ly9QejgvLzBoSVNQOU1URXovVEV4TS8waElTUDk2cjNmL2VyVjMvM3ExZC85NnIzZi9pN3FJLzJoRk1QOTFVRGovZFZBNC8zVlFPUDkxVURqL2FFVXcvNHU2aVA5NnRYZi9lcTkzLzNxMWQvOTZyM2YvaTdxSS80eStpditNdm9yL2pMNksvNHkraXYrTXZvci9qTDZLLzR1NmlQL3MxTGovNzltOS8relV1UC92MnIvLzh0L0kvL0xkd3YveTNjTC83TlM0Lyt6VXVQL3Yyci8vN05TNC8vTGZ5UC95M2NMLzh0M0Mvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCa1FTei9aRUVzLzJSQkxQOWtRU3ovS0Nnby95Z29LUDhvS0NqL0tDZ28vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTZKMU0vM3ExZC85NnIzZi8yTHFVLyt2VHMvL1l1cFQvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaRUVzLzJSQkxQOWtRU3ovWkVFcy95Z29LUDhvS0NqL0tDZ28veWdvS1A4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT1daUi8vb25Vei9lcTkzLzlpNmxQL3IwN1AvMkxxVS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdSQkxQOWtRU3ovWkVFcy8yUkJMUDhvS0NqL0tDZ28veWdvS1A4b0tDai9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEbG1VZi81WTAvLzNxdmQvL3IwN1AvMkxxVS8rdlRzLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmtRU3ovWkVFcy8yUkJMUDlrUVN6L0tDZ28veWdvS1A4b0tDai9LQ2dvL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE1WTAvLzNxMWQvOTZyM2YvNjlPei85aTZsUC9yMDdQL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCb1JURC9aRUVzLzJoRk1QOWtRU3ovYlVvei80QmFRUDk1VlQzL2FFVXcvMmhGTVA5a1FTei9hRVV3LzJSQkxQOXZURFgvZmJKNi80eStpditNdm9yL2VxOTMvM3ExZC85NnIzZi81WmxILytXTlAvK0x1b2ovaTdxSS8zcXZkLzk2cjNmL2VxOTMvM3F2ZC8rTHVvai9qTDZLLytXTlAvOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaRUVzLzJoRk1QOWtRU3ovYUVVdy8yaEZNUDk1VlQzL2VWVTkvM0pPTnY5a1FTei9hRVV3LzJoRk1QOWtRU3ovYjB3MS80QmFRUCtBV2tEL2NrNDIvM3F2ZC85NnIzZi9lcTkzLytpZFRQL2xtVWYvaTdxSS80dTZpUDk2cjNmL2VyVjMvM3F2ZC85NnIzZi9pN3FJLzR1NmlQK012b3IvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdSQkxQOW9SVEQvWkVFcy8yaEZNUDl5VGpiL2FFVXcvNEJhUVA5dlREWC9aRUVzLzJoRk1QOWtRU3ovYUVVdy8yOU1OZitBV2tEL2VWVTkvM0pPTnY5NnIzZi9lclYzLzNxMWQvOTZ0WGYvaTdxSS80eStpdjk5c25yL2VxOTMvM3ExZC85NnRYZi9lcTkzLzR5K2l2K0x1b2ovakw2Sy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmtRU3ovWkVFcy8yUkJMUDlvUlREL2NrNDIvM2xWUGY5b1JURC9hRVV3LzJSQkxQOW9SVEQvWkVFcy8yaEZNUDl2VERYL2dGcEEvM2xWUGY5eVRqYi9nSUphLzRlSll2K0hpV0wvZ0lKYS80YUhZZitQa0d2L2hvZGgvNENDV3YrSGlXTC9oNGxpLzRDQ1d2K0doMkgvajVCci80YUhZZjhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWkVFcy8yUkJMUDlrUVN6L1pFRXMvMjlNTmYrR1hrYi9obDVHLzI5TU5mOWtRU3ovWkVFcy8yUkJMUDlrUVN6L2FFVXcvMmhGTVA5b1JURC9hRVV3LytUSnFQL2t5YWovNU1tby8rVEpxUC9yMDdQLzY5T3ovK3ZUcy8va3lhai81TW1vLytUSnFQL2t5YWovNjlPei8rdlRzLy9yMDdQL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEczdPLzg3T3p2L096czcvMlJCTFA5b1JURC9lRlE4LzNoVVBQOW9SVEQvWkVFcy96czdPLzg3T3p2L096czcvMFpHUnY5R1JrYi9Sa1pHLzBaR1J2L2t5YWovNU1tby8rdlRzLy9yMDdQLzh0cTYvL0xhdXYvcjA3UC82OU96Lyt2VHMvL2t5YWovNjlPei8vTGF1di9yMDdQLzh0cTYvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJKU1VuL1NVbEovMGxKU2Y4N096di9XbHBhLzExZFhmOWRYVjMvV2xwYS96czdPLzlKU1VuL1NVbEovMGxKU2Y5TlRVMy9WMWRYLzFkWFYvOU5UVTMvNU1tby8rdlRzLy9yMDdQLzY5T3ovL0xhdXYveTJyci84dHE2Lyt2VHMvL3MxTGovNjlPei8relV1UC95MnJyLzh0cTYvL0xkd3Y4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVNVbEovMGxKU2Y5SlNVbi9TVWxKLzJGaFlmOXJhMnYvYTJ0ci8yRmhZZjlKU1VuL1NVbEovMGxKU2Y5SlNVbi9UVTFOLzFkWFYvOVhWMWYvVFUxTi8relV1UC9yMDdQLzdOUzQvKy9admYvcDBiUC84dHE2Ly9MYXV2L3IwN1AvN05TNC8rWExyZi9zMUxqLzh0cTYvL0xhdXYveTNjTC9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRWxKU2Y5SlNVbi9PenM3LzBsSlNmOWhZV0gvYTJ0ci8ydHJhLzloWVdIL1NVbEovenM3Ty85SlNVbi9TVWxKLzAxTlRmOVhWMWYvVjFkWC8wMU5UZi9zMUxqLzdOUzQvK3pVdVAvczFMai82ZEd6Ly9MZHd2L3kzY0wvN05TNC8relV1UC9zMUxqLzdOUzQvK25Scy8veTNjTC84dDNDL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCTlRVMy9UVTFOLzFKU1V2ODdPenYvV2xwYS8yTmpZLzlqWTJQL1dscGEvenM3Ty85U1VsTC9UVTFOLzAxTlRmOUtTa3IvVUZCUS8xQlFVUDlLU2tyLzdOUzQvK3pVdVAvdjJyLy83TlM0Ly9MZHd2L3kzY0wvNmRHei8relV1UC9zMUxqLzc5cS8vK3pVdVAveTNjTC84dDNDLy9MZHd2OEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFUVTFOLzAxTlRmOVNVbEwvWEZ4Yy8yRmhZZjlyYTJ2L2EydHIvMkZoWWY5Y1hGei9VbEpTLzAxTlRmOU5UVTMvU2twSy8xQlFVUDlRVUZEL1NrcEsvKy9hdi8vczFMai83OXEvLyt6VXVQL3kzY0wvOHQvSS8vTGR3di92MnIvLzdOUzQvK3pVdVAvdjJyLy84dDNDLy9MZnlQL3kzOGovQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ4L1AvOC9Qei8vUHo4Ly8xeGNYUDlqWTJQL2NIQncvM0J3Y1A5alkyUC9YRnhjL3o4L1AvOC9Qei8vUHo4Ly8waElTUDlNVEV6L1RFeE0vMGhJU1AvdjJyLy82OU96Lyt6VXVQL3MxTGovOHQvSS8vTGR3di95M2NMLzdOUzQvKy9hdi8vczFMai83TlM0Ly9MZHd2L3kzOGovOHQvSS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPT0iLCJTa2luSWQiOiJTdGFuZGFyZF9BbGV4In0K.gN2HJV9_WW1hvVj-gGKGJsCGEafIiGnTFgKRUKF2CqhiQk4dgB1dHFnZOglDN4VtW397jIPgs92ppMkyfZf8-09XQ87_o_eC1nvuscmBXt6Bn2UZQP_VYFqh_eCAXvCP";

			//string cert2 = "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEDEKneqEvcqUqqFMM1HM1A4zWjJC+I8Y+aKzG5dl+6wNOHHQ4NmG2PEXRJYhujyodFH+wO0dEr4GM1WoaWog8xsYQ6mQJAC0eVpBM96spUB1eMN56+BwlJ4H3Qx4TAvAs";
			//byte[] data = Base64Url.Decode(certString);
			string cert2 = @"MIIB0TCCATqgAwIBAgIQUq+2SdEkLr5K6xqjSEvRsDANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTIwODA0MDA0OTEyWhcNMTcwODA0MDAwMDAwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKjGuGT8NN5chlGSHIqEgjgceLQOX41f46MvYZMbGecoaFcl4yGAcU210oJeZyAjoZiuKueNdugqN4sTNq7IKpnK+cqNOr44aH1lCh6zAPz+KT/KtKuOBhXvYpv6QL4eDVVYpMfHNk120xaItE+pk75ZKh6aXmh+v4HIFD/Off8XAgMBAAGjJDAiMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATANBgkqhkiG9w0BAQUFAAOBgQCIBC/BE4ObFNbI6UV7bpg4abxrQDG+HYhMrLyw29jB4KNyeJPzkDHUkTuaY2nd44bYEpmaBy7XJ5UIGEkuD3VIxT2S+2bCwkRR+9/+7vggR2q7l7YEktM2mFBIyqOMOroAw+5cdc06c/B7UimwKFczsyhi9LUIr3rXI42FdXBHWw==";
			byte[] cert3 = Base64Url.Decode(cert2);
			Log.Debug($"Data: {Encoding.UTF8.GetString(cert3)}");

			var cert = new X509Certificate2();
			cert.Import(cert3);
			//var cert = new X509Certificate2();
			//cert.Import(@"D:\Temp\test.cer");

			//Log.Debug($"Cert: { cert }");
			//cert.Import(data);


			//string skinPayload = JWT.Payload(t);
			//Log.Debug($"JWT Payload SKIN: {skinPayload  }");

			Datagram.CreateObject().PutPool();


			if (_listener != null) return false; // Already started

			try
			{
				Log.Info("Initializing...");

				InacvitityTimeout = Config.GetProperty("InactivityTimeout", 8500);

				if (Endpoint == null)
				{
					var ip = IPAddress.Parse(Config.GetProperty("ip", "0.0.0.0"));
					int port = Config.GetProperty("port", 19132);
					Endpoint = new IPEndPoint(ip, port);
				}

				ForwardAllPlayers = Config.GetProperty("ForwardAllPlayers", false);
				if (ForwardAllPlayers)
				{
					var ip = IPAddress.Parse(Config.GetProperty("ForwardIP", "127.0.0.1"));
					int port = Config.GetProperty("ForwardPort", 19132);
					ForwardTarget = new IPEndPoint(ip, port);
				}

				Log.Info("Loading plugins...");
				PluginManager = new PluginManager();
				PluginManager.LoadPlugins();
				Log.Info("Plugins loaded!");

				// Bootstrap server
				PluginManager.ExecuteStartup(this);

				MotdProvider = MotdProvider ?? new MotdProvider();

				IsSecurityEnabled = Config.GetProperty("EnableSecurity", false);
				if (IsSecurityEnabled)
				{
					// http://www.asp.net/identity/overview/extensibility/overview-of-custom-storage-providers-for-aspnet-identity
					UserManager = UserManager ?? new UserManager<User>(new DefaultUserStore());
					RoleManager = RoleManager ?? new RoleManager<Role>(new DefaultRoleStore());
				}

				GreylistManager = GreylistManager ?? new GreylistManager(this);
				SessionManager = SessionManager ?? new SessionManager();
				LevelManager = LevelManager ?? new LevelManager();
				PlayerFactory = PlayerFactory ?? new PlayerFactory();

				PluginManager.EnablePlugins(this, LevelManager);

				// Cache - remove
				LevelManager.GetLevel(null, "Default");

				_listener = new UdpClient(Endpoint);

				if (IsRunningOnMono())
				{
					_listener.Client.ReceiveBufferSize = 1024*1024*3;
					_listener.Client.SendBufferSize = 4096;
				}
				else
				{
					//_listener.Client.ReceiveBufferSize = 1600*40000;
					_listener.Client.ReceiveBufferSize = int.MaxValue;
					//_listener.Client.SendBufferSize = 1600*40000;
					_listener.Client.SendBufferSize = int.MaxValue;
					_listener.DontFragment = false;
					_listener.EnableBroadcast = false;

					// SIO_UDP_CONNRESET (opcode setting: I, T==3)
					// Windows:  Controls whether UDP PORT_UNREACHABLE messages are reported.
					// - Set to TRUE to enable reporting.
					// - Set to FALSE to disable reporting.

					uint IOC_IN = 0x80000000;
					uint IOC_VENDOR = 0x18000000;
					uint SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;
					_listener.Client.IOControl((int) SIO_UDP_CONNRESET, new byte[] {Convert.ToByte(false)}, null);

					//
					//WARNING: We need to catch errors here to remove the code above.
					//
				}

				_ackTimer = new Timer(SendAckQueue, null, 0, 10);
				_cleanerTimer = new Timer(Update, null, 10, Timeout.Infinite);

				_listener.BeginReceive(ReceiveCallback, _listener);

				// Measure latency through system
				//_internalPingTimer = new Timer(delegate(object state)
				//{
				//	var playerSession = _playerSessions.Values.FirstOrDefault();
				//	if (playerSession != null)
				//	{
				//		var ping = new InternalPing();
				//		ping.Timer.Start();
				//		HandlePackage(ping, playerSession);
				//	}
				//}, null, 1000, 1000);

				ServerInfo = new ServerInfo(LevelManager, _playerSessions)
				{
					MaxNumberOfPlayers = Config.GetProperty("MaxNumberOfPlayers", 1000)
				};
				ServerInfo.MaxNumberOfConcurrentConnects = Config.GetProperty("MaxNumberOfConcurrentConnects", ServerInfo.MaxNumberOfPlayers);

				Log.Info("Server open for business on port " + Endpoint.Port + " ...");

				return true;
			}
			catch (Exception e)
			{
				Log.Error("Error during startup!", e);
				StopServer();
			}

			return false;
		}

		public bool StopServer()
		{
			try
			{
				Log.Info("Disabling plugins...");
				PluginManager.DisablePlugins();

				Log.Info("Shutting down...");
				if (_listener == null) return true; // Already stopped. It's ok.

				_listener.Close();
				_listener = null;

				return true;
			}
			catch (Exception e)
			{
				Log.Error(e);
			}

			return false;
		}

		private void ReceiveCallback(IAsyncResult ar)
		{
			UdpClient listener = (UdpClient) ar.AsyncState;

			// Check if we already closed the server
			if (listener.Client == null) return;

			// WSAECONNRESET:
			// The virtual circuit was reset by the remote side executing a hard or abortive close. 
			// The application should close the socket; it is no longer usable. On a UDP-datagram socket 
			// this error indicates a previous send operation resulted in an ICMP Port Unreachable message.
			// Note the spocket settings on creation of the server. It makes us ignore these resets.
			IPEndPoint senderEndpoint = new IPEndPoint(0, 0);
			Byte[] receiveBytes = null;
			try
			{
				receiveBytes = listener.EndReceive(ar, ref senderEndpoint);
			}
			catch (Exception e)
			{
				Log.Error("Unexpected end of transmission?", e);
				if (listener.Client != null)
				{
					try
					{
						listener.BeginReceive(ReceiveCallback, listener);
					}
					catch (ObjectDisposedException dex)
					{
						Log.Error("Unexpected end of transmission?", dex);
					}
				}

				return;
			}

			if (receiveBytes.Length != 0)
			{
				listener.BeginReceive(ReceiveCallback, listener);

				Interlocked.Exchange(ref ServerInfo.AvailableBytes, listener.Available);
				Interlocked.Increment(ref ServerInfo.NumberOfPacketsInPerSecond);
				Interlocked.Add(ref ServerInfo.TotalPacketSizeIn, receiveBytes.Length);

				try
				{
					if (!GreylistManager.IsWhitelisted(senderEndpoint.Address) && GreylistManager.IsBlacklisted(senderEndpoint.Address)) return;
					if (GreylistManager.IsGreylisted(senderEndpoint.Address)) return;
					ProcessMessage(receiveBytes, senderEndpoint);
				}
				catch (Exception e)
				{
					Log.Warn(string.Format("Process message error from: {0}", senderEndpoint.Address), e);
				}
			}
			else
			{
				Log.Error("Unexpected end of transmission?");
			}
		}

		private void ProcessMessage(byte[] receiveBytes, IPEndPoint senderEndpoint)
		{
			byte msgId = receiveBytes[0];

			if (msgId == 0xFE)
			{
				Log.InfoFormat("A query detected from: {0}", senderEndpoint.Address);
				HandleQuery(receiveBytes, senderEndpoint);
			}
			else if (msgId <= (byte) DefaultMessageIdTypes.ID_USER_PACKET_ENUM)
			{
				HandleRakNetMessage(receiveBytes, senderEndpoint, msgId);
			}
			else
			{
				PlayerNetworkSession playerSession;
				if (!_playerSessions.TryGetValue(senderEndpoint, out playerSession))
				{
					//Log.DebugFormat("Receive MCPE message 0x{1:x2} without session {0}", senderEndpoint.Address, msgId);
					//if (!_badPacketBans.ContainsKey(senderEndpoint.Address))
					//{
					//	_badPacketBans.Add(senderEndpoint.Address, true);
					//}
					return;
				}

				Player player = playerSession.Player;

				if (player == null)
				{
					Log.ErrorFormat("Receive MCPE message 0x{1:x2} without player {0}. Session removed.", senderEndpoint.Address, msgId);
					_playerSessions.TryRemove(senderEndpoint, out playerSession);
					//if (!_badPacketBans.ContainsKey(senderEndpoint.Address))
					//{
					//	_badPacketBans.Add(senderEndpoint.Address, true);
					//}
					return;
				}

				if (playerSession.Evicted) return;

				playerSession.LastUpdatedTime = DateTime.UtcNow;

				DatagramHeader header = new DatagramHeader(receiveBytes[0]);
				if (!header.isACK && !header.isNAK && header.isValid)
				{
					if (receiveBytes[0] == 0xa0)
					{
						throw new Exception("Receive ERROR, NAK in wrong place");
					}

					ConnectedPackage package = ConnectedPackage.CreateObject();
					try
					{
						package.Decode(receiveBytes);
					}
					catch (Exception e)
					{
						player.Disconnect("Bad package received from client.");
						//if (Log.IsDebugEnabled)
						{
							Log.Warn("Bad packet " + receiveBytes[0], e);
						}

						GreylistManager.Blacklist(senderEndpoint.Address);

						return;
					}


					// IF reliable code below is enabled, useItem start sending doubles
					// for some unknown reason.

					//Reliability reliability = package._reliability;
					//if (reliability == Reliability.Reliable
					//	|| reliability == Reliability.ReliableSequenced
					//	|| reliability == Reliability.ReliableOrdered
					//	)
					{
						EnqueueAck(playerSession, package._datagramSequenceNumber);
					}

					DelayedProcessing(playerSession, package);
					package.PutPool();
				}
				else if (header.isACK && header.isValid)
				{
					HandleAck(playerSession, receiveBytes);
				}
				else if (header.isNAK && header.isValid)
				{
					HandleNak(playerSession, receiveBytes);
				}
				else if (!header.isValid)
				{
					Log.Warn("!!!! ERROR, Invalid header !!!!!");
				}
			}
		}

		private ConcurrentDictionary<IPEndPoint, DateTime> _connectionAttemps = new ConcurrentDictionary<IPEndPoint, DateTime>();

		private void HandleRakNetMessage(byte[] receiveBytes, IPEndPoint senderEndpoint, byte msgId)
		{
			DefaultMessageIdTypes msgIdType = (DefaultMessageIdTypes) msgId;

			// Increase fast, decrease slow on 1s ticks.
			if (ServerInfo.NumberOfPlayers < ServerInfo.PlayerSessions.Count) ServerInfo.NumberOfPlayers = ServerInfo.PlayerSessions.Count;

			// Shortcut to reply fast, and no parsing
			if (msgIdType == DefaultMessageIdTypes.ID_OPEN_CONNECTION_REQUEST_1)
			{
				if (!GreylistManager.AcceptConnection(senderEndpoint.Address))
				{
					var noFree = NoFreeIncomingConnections.CreateObject();
					var bytes = noFree.Encode();
					noFree.PutPool();

					TraceSend(noFree);

					SendData(bytes, senderEndpoint);
					Interlocked.Increment(ref ServerInfo.NumberOfDeniedConnectionRequestsPerSecond);
					return;
				}
			}

			Package message = null;
			try
			{
				try
				{
					message = PackageFactory.CreatePackage(msgId, receiveBytes, "raknet");
				}
				catch (Exception)
				{
					message = null;
				}

				if (message == null)
				{
					GreylistManager.Blacklist(senderEndpoint.Address);
					Log.ErrorFormat("Receive bad packet with ID: {0} (0x{0:x2}) {2} from {1}", msgId, senderEndpoint.Address, (DefaultMessageIdTypes) msgId);

					return;
				}

				TraceReceive(message);

				switch (msgIdType)
				{
					case DefaultMessageIdTypes.ID_UNCONNECTED_PING:
					case DefaultMessageIdTypes.ID_UNCONNECTED_PING_OPEN_CONNECTIONS:
					{
						HandleRakNetMessage(senderEndpoint, (UnconnectedPing) message);
						break;
					}
					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REQUEST_1:
					{
						HandleRakNetMessage(senderEndpoint, (OpenConnectionRequest1) message);
						break;
					}
					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REQUEST_2:
					{
						HandleRakNetMessage(senderEndpoint, (OpenConnectionRequest2) message);
						break;
					}
					default:
						GreylistManager.Blacklist(senderEndpoint.Address);
						Log.ErrorFormat("Receive unexpected packet with ID: {0} (0x{0:x2}) {2} from {1}", msgId, senderEndpoint.Address, (DefaultMessageIdTypes) msgId);
						break;
				}
			}
			finally
			{
				if (message != null) message.PutPool();
			}
		}

		private void HandleRakNetMessage(IPEndPoint senderEndpoint, UnconnectedPing incoming)
		{
			//TODO: This needs to be verified with RakNet first
			//response.sendpingtime = msg.sendpingtime;
			//response.sendpongtime = DateTimeOffset.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;

			var packet = UnconnectedPong.CreateObject();
			packet.serverId = 22345;
			packet.pingId = incoming.pingId;
			packet.serverName = MotdProvider.GetMotd(ServerInfo);
			var data = packet.Encode();
			packet.PutPool();

			TraceSend(packet);

			SendData(data, senderEndpoint);
			return;
		}

		private void HandleRakNetMessage(IPEndPoint senderEndpoint, OpenConnectionRequest1 incoming)
		{
			lock (_playerSessions)
			{
				// Already connecting, then this is just a duplicate
				if (_connectionAttemps.ContainsKey(senderEndpoint))
				{
					DateTime created;
					_connectionAttemps.TryGetValue(senderEndpoint, out created);

					if (DateTime.UtcNow < created + TimeSpan.FromSeconds(3))
					{
						return;
					}

					_connectionAttemps.TryRemove(senderEndpoint, out created);
				}

				if (!_connectionAttemps.TryAdd(senderEndpoint, DateTime.UtcNow)) return;
			}

			if (Log.IsDebugEnabled)
				Log.WarnFormat("New connection from: {0} {1}, MTU: {2}", senderEndpoint.Address, senderEndpoint.Port, incoming.mtuSize);

			var packet = OpenConnectionReply1.CreateObject();
			packet.serverGuid = 12345;
			packet.mtuSize = incoming.mtuSize;
			packet.serverHasSecurity = 0;
			var data = packet.Encode();
			packet.PutPool();

			TraceSend(packet);

			SendData(data, senderEndpoint);
		}

		private void HandleRakNetMessage(IPEndPoint senderEndpoint, OpenConnectionRequest2 incoming)
		{
			PlayerNetworkSession session;
			lock (_playerSessions)
			{
				DateTime trash;
				if (!_connectionAttemps.TryRemove(senderEndpoint, out trash))
				{
					Log.WarnFormat("Unexpected connection request packet from {0}. Probably a resend.", senderEndpoint.Address);
					return;
				}

				if (_playerSessions.TryGetValue(senderEndpoint, out session))
				{
					// Already connecting, then this is just a duplicate
					if (session.State == ConnectionState.Connecting /* && DateTime.UtcNow < session.LastUpdatedTime + TimeSpan.FromSeconds(2)*/)
					{
						return;
					}

					Log.InfoFormat("Unexpected session from {0}. Removing old session and disconnecting old player.", senderEndpoint.Address);

					Player oldPlayer = session.Player;
					oldPlayer?.Disconnect("Reconnecting.", false);

					_playerSessions.TryRemove(senderEndpoint, out session);
				}

				session = new PlayerNetworkSession(null, senderEndpoint, incoming.mtuSize)
				{
					State = ConnectionState.Connecting,
					LastUpdatedTime = DateTime.UtcNow,
					Mtuize = incoming.mtuSize
				};

				_playerSessions.TryAdd(senderEndpoint, session);
			}

			Player player = PlayerFactory.CreatePlayer(this, senderEndpoint);
			player.ClientGuid = incoming.clientGuid;
			player.NetworkSession = session;
			session.Player = player;

			var reply = OpenConnectionReply2.CreateObject();
			reply.serverGuid = 12345;
			reply.clientendpoint = senderEndpoint;
			reply.mtuSize = incoming.mtuSize;
			reply.doSecurityAndHandshake = new byte[1];
			var data = reply.Encode();
			reply.PutPool();

			TraceSend(reply);

			SendData(data, senderEndpoint);
		}

		private ManualResetEvent _waitEvent = new ManualResetEvent(false);

		private void DelayedProcessing(PlayerNetworkSession playerSession, ConnectedPackage package)
		{
			Player player = playerSession.Player;

			long sequenceNumber = package._orderingIndex.IntValue();

			Log.Debug($"Received Dgrm: #{package._datagramSequenceNumber} {package._reliability} message #{package._reliableMessageNumber}, Chan: #{package._orderingChannel}, OrdIdx: #{package._orderingIndex}");

			//if (new Random().Next(20) == 0)
			//{
			//	// Debug force packet unordered.
			//	Log.Debug($"Sleeping on #{sequenceNumber} to create chaos");
			//	//Thread.Sleep(50);
			//}

			int countDown = (int) (sequenceNumber + Interlocked.Read(ref playerSession.LastSequenceNumber) + 5);
			bool waited = false;
			while (!package._hasSplit && package._reliability == Reliability.ReliableOrdered && countDown > 0)
			{
				countDown--;
				if (sequenceNumber <= playerSession.LastSequenceNumber)
				{
					Log.Warn($"Detected resend out of order for {player?.Username} #{sequenceNumber}");
					return;
				}

				long comparand = sequenceNumber - 1L;
				var current = Interlocked.CompareExchange(ref playerSession.LastSequenceNumber, sequenceNumber, comparand);
				if (current != comparand)
				{
					Log.Warn($"Recived datagrams out of order for {player?.Username} (Attempts left: {countDown}) Current: #{current} != New: #{sequenceNumber} - 1");
					if (playerSession.Evicted) return;
					_waitEvent.Reset();
					if(!_waitEvent.WaitOne(1000))
					{
						Log.Warn($"Continue without signal {player?.Username} (Attempts left: {countDown}) Current: #{current} != New: #{sequenceNumber} - 1");
					}
					waited = true;
					continue;
				}

				if (waited)
				{
					Log.Warn($"Caught up on datagrams out of order for {player?.Username} #{sequenceNumber}");
				}

				break;
			}

			if (countDown <= 0)
			{
				//Interlocked.CompareExchange(ref playerSession.LastSequenceNumber, playerSession.LastSequenceNumber + 1, playerSession.LastSequenceNumber);
				Log.Error($"Never caught up with datagram sequence for {player?.Username} #{sequenceNumber}");
				//throw new Exception("Never caught up with datagram sequence");
				DelayedProcessing(playerSession, package);
			}

			List<Package> messages = package.Messages;
			foreach (var message in messages)
			{
				message.DatagramSequenceNumber = package._datagramSequenceNumber;
				//message.ReliableMessageNumber = package._reliableMessageNumber;
				//message.OrderingChannel = package._orderingChannel;
				//message.OrderingIndex = package._orderingIndex;

				if (message is SplitPartPackage)
				{
					HandleSplitMessage(playerSession, package, (SplitPartPackage) message, player);

					continue;
				}

				message.Timer.Restart();
				HandlePackage(message, playerSession);
				message.PutPool(); // Handled in HandlePacket now()
			}

			_waitEvent.Set(); // Release all threads waiting to check for ordered datagrams above.
		}

		private void HandleSplitMessage(PlayerNetworkSession playerSession, ConnectedPackage package, SplitPartPackage splitMessage, Player player)
		{
			int spId = package._splitPacketId;
			int spIdx = package._splitPacketIndex;
			int spCount = package._splitPacketCount;

			if (!playerSession.Splits.ContainsKey(spId))
			{
				playerSession.Splits.TryAdd(spId, new SplitPartPackage[spCount]);
			}

			SplitPartPackage[] spPackets = playerSession.Splits[spId];
			spPackets[spIdx] = splitMessage;

			bool haveEmpty = false;
			for (int i = 0; i < spPackets.Length; i++)
			{
				haveEmpty = haveEmpty || spPackets[i] == null;
			}

			if (!haveEmpty)
			{
				Log.DebugFormat("Got all {0} split packages for split ID: {1}", spCount, spId);

				SplitPartPackage[] waste;
				playerSession.Splits.TryRemove(spId, out waste);

				MemoryStream stream = MemoryStreamManager.GetStream();
				for (int i = 0; i < spPackets.Length; i++)
				{
					SplitPartPackage splitPartPackage = spPackets[i];
					byte[] buf = splitPartPackage.Message;
					if (buf == null)
					{
						Log.Error("Expected bytes in splitpart, but got none");
						continue;
					}

					stream.Write(buf, 0, buf.Length);
					splitPartPackage.PutPool();
				}

				byte[] buffer = stream.ToArray();
				try
				{
					ConnectedPackage newPackage = ConnectedPackage.CreateObject();
					newPackage._datagramSequenceNumber = package._datagramSequenceNumber;
					newPackage._reliability = package._reliability;
					newPackage._reliableMessageNumber = package._reliableMessageNumber;
					newPackage._sequencingIndex = package._sequencingIndex;
					newPackage._orderingIndex = package._orderingIndex;
					newPackage._orderingChannel = package._orderingChannel;
					newPackage._hasSplit = false;

					Package fullMessage = PackageFactory.CreatePackage(buffer[0], buffer, "raknet") ?? new UnknownPackage(buffer[0], buffer);
					newPackage.Messages = new List<Package>();
					newPackage.Messages.Add(fullMessage);
					Log.Debug($"Assembled split package {newPackage._reliability} message #{newPackage._reliableMessageNumber}, Chan: #{newPackage._orderingChannel}, OrdIdx: #{newPackage._orderingIndex}");
					DelayedProcessing(playerSession, newPackage);
					newPackage.PutPool();
				}
				catch (Exception e)
				{
					Log.Error("Error during split message parsing", e);
					if (Log.IsDebugEnabled)
						Log.Debug($"0x{buffer[0]:x2}\n{Package.HexDump(buffer)}");
					player.Disconnect("Bad package received from client.");
				}
			}
		}

		private void HandleQuery(byte[] receiveBytes, IPEndPoint senderEndpoint)
		{
			if (!Config.GetProperty("EnableQuery", false)) return;

			if (receiveBytes[0] != 0xFE || receiveBytes[1] != 0xFD) return;

			byte packetId = receiveBytes[2];
			switch (packetId)
			{
				case 0x09:
				{
					byte[] buffer = new byte[17];
					// ID
					buffer[0] = 0x09;

					// Sequence number
					buffer[1] = receiveBytes[3];
					buffer[2] = receiveBytes[4];
					buffer[3] = receiveBytes[5];
					buffer[4] = receiveBytes[6];

					// Textual representation of int32 (token) with null terminator
					string str = new Random().Next().ToString(CultureInfo.InvariantCulture) + "\x00";
					Buffer.BlockCopy(str.ToCharArray(), 0, buffer, 5, 11);

					_listener.Send(buffer, buffer.Length, senderEndpoint);
					break;
				}
				case 0x00:
				{
					var stream = MemoryStreamManager.GetStream();

					bool isFullStatRequest = receiveBytes.Length == 15;
					if (Log.IsInfoEnabled) Log.InfoFormat("Full request: {0}", isFullStatRequest);

					// ID
					stream.WriteByte(0x00);

					// Sequence number
					stream.WriteByte(receiveBytes[3]);
					stream.WriteByte(receiveBytes[4]);
					stream.WriteByte(receiveBytes[5]);
					stream.WriteByte(receiveBytes[6]);

					//{
					//	string str = "splitnum\0";
					//	byte[] bytes = Encoding.ASCII.GetBytes(str.ToCharArray());
					//	stream.Write(bytes, 0, bytes.Length);
					//}

					MotdProvider.GetMotd(ServerInfo); // Force update the player counts :-)

					var data = new Dictionary<string, string>
					{
						{"splitnum", "" + (char) 128},
						{"hostname", "Minecraft PE Server"},
						{"gametype", "SMP"},
						{"game_id", "MINECRAFTPE"},
						{"version", "0.15.0"},
						{"server_engine", "MiNET v1.0.0"},
						{"plugins", "MiNET v1.0.0"},
						{"map", "world"},
						{"numplayers", MotdProvider.NumberOfPlayers.ToString()},
						{"maxplayers", MotdProvider.MaxNumberOfPlayers.ToString()},
						{"whitelist", "off"},
						//{"hostip", "192.168.0.1"},
						//{"hostport", "19132"}
					};

					foreach (KeyValuePair<string, string> valuePair in data)
					{
						string key = valuePair.Key + "\x00" + valuePair.Value + "\x00";
						byte[] bytes = Encoding.ASCII.GetBytes(key.ToCharArray());
						stream.Write(bytes, 0, bytes.Length);
					}

					{
						string str = "\x00\x01player_\x00\x00";
						byte[] bytes = Encoding.ASCII.GetBytes(str.ToCharArray());
						stream.Write(bytes, 0, bytes.Length);
					}

					// End the stream with 0 byte
					stream.WriteByte(0);
					var buffer = stream.ToArray();
					_listener.Send(buffer, buffer.Length, senderEndpoint);
					break;
				}
				default:
					return;
			}
		}

		private void HandleNak(PlayerNetworkSession session, byte[] receiveBytes)
		{
			if (session == null) return;

			Player player = session.Player;
			if (player == null) return;

			Nak nak = Nak.CreateObject();
			nak.Reset();
			nak.Decode(receiveBytes);

			var queue = session.WaitingForAcksQueue;

			foreach (Tuple<int, int> range in nak.ranges)
			{
				Interlocked.Increment(ref ServerInfo.NumberOfNakReceive);

				int start = range.Item1;
				int end = range.Item2;

				for (int i = start; i <= end; i++)
				{
					session.ErrorCount++;

					// HACK: Just to make sure we aren't getting unessecary load on the queue during heavy buffering.
					if (ServerInfo.AvailableBytes > 1000) continue;

					Datagram datagram;
					if (queue.TryGetValue(i, out datagram))
					{
						// RTT = RTT * 0.875 + rtt * 0.125
						// RTTVar = RTTVar * 0.875 + abs(RTT - rtt)) * 0.125
						// RTO = RTT + 4 * RTTVar
						long rtt = datagram.Timer.ElapsedMilliseconds;
						long RTT = player.Rtt;
						long RTTVar = player.RttVar;

						player.Rtt = (long) (RTT*0.875 + rtt*0.125);
						player.RttVar = (long) (RTTVar*0.875 + Math.Abs(RTT - rtt)*0.125);
						player.Rto = player.Rtt + 4*player.RttVar + 100; // SYNC time in the end
					}
					else
					{
						if (Log.IsDebugEnabled)
							Log.WarnFormat("NAK, no datagram #{0} for {1}", i, player.Username);
					}
				}
			}

			nak.PutPool();
		}

		private void HandleAck(PlayerNetworkSession session, byte[] receiveBytes)
		{
			if (session == null) return;

			Player player = session.Player;
			if (player == null) return;

			//Ack ack = Ack.CreateObject();
			Ack ack = new Ack();
			//ack.Reset();
			ack.Decode(receiveBytes);

			var queue = session.WaitingForAcksQueue;

			foreach (Tuple<int, int> range in ack.ranges)
			{
				Interlocked.Increment(ref ServerInfo.NumberOfAckReceive);

				int start = range.Item1;
				int end = range.Item2;
				for (int i = start; i <= end; i++)
				{
					Datagram datagram;
					if (queue.TryRemove(i, out datagram))
					{
						//if (Log.IsDebugEnabled)
						//	Log.DebugFormat("ACK, on datagram #{0} for {2}. Queue size={1}", i, queue.Count, player.Username);

						// RTT = RTT * 0.875 + rtt * 0.125
						// RTTVar = RTTVar * 0.875 + abs(RTT - rtt)) * 0.125
						// RTO = RTT + 4 * RTTVar
						long rtt = datagram.Timer.ElapsedMilliseconds;
						long RTT = player.Rtt;
						long RTTVar = player.RttVar;

						player.Rtt = (long) (RTT*0.875 + rtt*0.125);
						player.RttVar = (long) (RTTVar*0.875 + Math.Abs(RTT - rtt)*0.125);
						player.Rto = player.Rtt + 4*player.RttVar + 100; // SYNC time in the end

						datagram.PutPool();
					}
					else
					{
						if (Log.IsDebugEnabled)
							Log.WarnFormat("ACK, Failed to remove datagram #{0} for {2}. Queue size={1}", i, queue.Count, player.Username);
					}
				}
			}

			//ack.PutPool();

			session.ResendCount = 0;
			session.WaitForAck = false;
		}

		internal void HandlePackage(Package message, PlayerNetworkSession playerSession)
		{
			Player player = playerSession.Player;

			if (message == null)
			{
				return;
			}

			TraceReceive(message, message.ReliableMessageNumber);

			if (typeof (UnknownPackage) == message.GetType())
			{
				UnknownPackage packet = (UnknownPackage) message;
				Log.Warn($"Received unknown package 0x{message.Id:X2}\n{Package.HexDump(packet.Message)}");
				return;
			}

			if (typeof (McpeWrapper) == message.GetType())
			{
				McpeWrapper batch = (McpeWrapper) message;

				// Get bytes
				byte[] payload = batch.payload;
				if (playerSession.CryptoContext != null)
				{
					payload = CryptoUtils.Decrypt(payload, playerSession.CryptoContext);
				}

				//if (Log.IsDebugEnabled)
				//	Log.Debug($"0x{payload[0]:x2}\n{Package.HexDump(payload)}");

				message = PackageFactory.CreatePackage(payload[0], payload, "mcpe") ?? new UnknownPackage(payload[0], payload);
			}


			if (typeof (McpeBatch) == message.GetType())
			{
				Log.Debug("Handle MCPE batch message");
				McpeBatch batch = (McpeBatch) message;

				var messages = new List<Package>();

				// Get bytes
				byte[] payload = batch.payload;
				// Decompress bytes

				MemoryStream stream = new MemoryStream(payload);
				if (stream.ReadByte() != 0x78)
				{
					throw new InvalidDataException("Incorrect ZLib header. Expected 0x78 0x9C");
				}
				stream.ReadByte();
				using (var defStream2 = new DeflateStream(stream, CompressionMode.Decompress, false))
				{
					// Get actual package out of bytes
					MemoryStream destination = MemoryStreamManager.GetStream();
					defStream2.CopyTo(destination);
					destination.Position = 0;
					NbtBinaryReader reader = new NbtBinaryReader(destination, true);

					while (destination.Position < destination.Length)
					{
						int len = reader.ReadInt32();
						byte[] internalBuffer = reader.ReadBytes(len);

						//if (Log.IsDebugEnabled)
						//	Log.Debug($"0x{internalBuffer[0]:x2}\n{Package.HexDump(internalBuffer)}");

						messages.Add(PackageFactory.CreatePackage(internalBuffer[0], internalBuffer, "mcpe") ?? new UnknownPackage(internalBuffer[0], internalBuffer));
					}

					if (destination.Length > destination.Position) throw new Exception("Have more data");
				}
				foreach (var msg in messages)
				{
					msg.DatagramSequenceNumber = batch.DatagramSequenceNumber;
					msg.OrderingChannel = batch.OrderingChannel;
					msg.OrderingIndex = batch.OrderingIndex;
					HandlePackage(msg, playerSession);
					msg.PutPool();
				}

				return;
			}

			if (player != null) player.HandlePackage(message);
		}

		private void EnqueueAck(PlayerNetworkSession session, int sequenceNumber)
		{
			Interlocked.Increment(ref ServerInfo.NumberOfAckSent);
			session.PlayerAckQueue.Enqueue(sequenceNumber);
		}

		private void SendAckQueue(object state)
		{
			var sessions = _playerSessions.Values.ToArray();

			foreach (var s in sessions)
			{
				ThreadPool.QueueUserWorkItem(delegate(object o)
				{
					PlayerNetworkSession session = (PlayerNetworkSession) o;
					var queue = session.PlayerAckQueue;
					int lenght = queue.Count;

					if (lenght == 0) return;

					Acks acks = Acks.CreateObject();
					for (int i = 0; i < lenght; i++)
					{
						int ack;
						if (!session.PlayerAckQueue.TryDequeue(out ack)) break;

						acks.acks.Add(ack);
					}

					if (acks.acks.Count > 0)
					{
						byte[] data = acks.Encode();
						SendData(data, session.EndPoint);
					}

					acks.PutPool();
				}, s);
			}
		}

		private object _updateGlobalLock = new object();

		private Stopwatch _forceQuitTimer = new Stopwatch();

		private void Update(object state)
		{
			if (!Monitor.TryEnter(_updateGlobalLock)) return;
			_forceQuitTimer.Restart();

			try
			{
				long now = DateTime.UtcNow.Ticks/TimeSpan.TicksPerMillisecond;

				Parallel.ForEach(_playerSessions, delegate(KeyValuePair<IPEndPoint, PlayerNetworkSession> pair)
				{
					PlayerNetworkSession session = pair.Value;

					if (session == null) return;
					if (session.Evicted) return;

					Player player = session.Player;

					long lastUpdate = session.LastUpdatedTime.Ticks/TimeSpan.TicksPerMillisecond;
					bool serverHasNoLag = ServerInfo.AvailableBytes < 1000;

					if (serverHasNoLag && lastUpdate + InacvitityTimeout + 3000 < now)
					{
						session.Evicted = true;
						// Disconnect user
						ThreadPool.QueueUserWorkItem(delegate(object o)
						{
							PlayerNetworkSession s = o as PlayerNetworkSession;
							if (s != null)
							{
								Player p = s.Player;
								if (p != null)
								{
									p.Disconnect("You've been kicked with reason: Network timeout.");
								}
								else
								{
									if (ServerInfo.PlayerSessions.TryRemove(session.EndPoint, out session))
									{
										session.Player = null;
										session.State = ConnectionState.Unconnected;
										session.Evicted = true;
										session.Clean();
									}
								}
							}
						}, session);

						return;
					}


					if (serverHasNoLag && session.State != ConnectionState.Connected && player != null && lastUpdate + 3000 < now)
					{
						ThreadPool.QueueUserWorkItem(delegate(object o)
						{
							PlayerNetworkSession s = o as PlayerNetworkSession;
							if (s != null)
							{
								Player p = s.Player;
								if (p != null) p.Disconnect("You've been kicked with reason: Lost connection.");
							}
						}, session);

						return;
					}

					if (player == null) return;

					if (serverHasNoLag && lastUpdate + InacvitityTimeout < now && !session.WaitForAck)
					{
						player.DetectLostConnection();
						session.WaitForAck = true;
					}

					if (player.Rto == 0) return;

					long rto = Math.Max(100, player.Rto);
					var queue = session.WaitingForAcksQueue;

					foreach (KeyValuePair<int, Datagram> datagramPair in queue)
					{
						// We don't do too much processing in each step, becasue one bad queue will hold the others.
						//if (_forceQuitTimer.ElapsedMilliseconds > 100)
						//{
						//	Log.WarnFormat("Update aborted early");
						//	return;
						//}

						var datagram = datagramPair.Value;

						if (!datagram.Timer.IsRunning)
						{
							Log.ErrorFormat("Timer not running for #{0}", datagram.Header.datagramSequenceNumber);
							datagram.Timer.Restart();
							continue;
						}

						if (player.Rtt == -1) return;

						//if (session.WaitForAck) return;

						long elapsedTime = datagram.Timer.ElapsedMilliseconds;
						long datagramTimout = rto*(datagram.TransmissionCount + session.ResendCount + 1);
						datagramTimout = Math.Min(datagramTimout, 3000);

						//if(elapsedTime > 5000)
						//{
						//	Datagram deleted;
						//	queue.TryRemove(datagram.Header.datagramSequenceNumber, out deleted);
						//}
						//else 
						if (serverHasNoLag && elapsedTime >= datagramTimout)
						{
							//if (session.WaitForAck) return;

							//session.WaitForAck = session.ResendCount++ > 3;

							Datagram deleted;
							if (queue.TryRemove(datagram.Header.datagramSequenceNumber, out deleted))
							{
								session.ErrorCount++;

								if (deleted.TransmissionCount > 3)
								{
									if (Log.IsDebugEnabled)
										Log.WarnFormat("TIMEOUT, Retransmission count remove from ACK queue #{0} Type: {2} (0x{2:x2}) for {1} ({3} > {4}) RTO {5}",
											deleted.Header.datagramSequenceNumber.IntValue(),
											player.Username,
											deleted.FirstMessageId,
											elapsedTime,
											datagramTimout,
											rto);

									deleted.PutPool();

									//session.WaitForAck = true;

									Interlocked.Increment(ref ServerInfo.NumberOfFails);

									continue;
								}

								if (!session.Evicted)
								{
									ThreadPool.QueueUserWorkItem(delegate(object data)
									{
										if (Log.IsDebugEnabled)
											Log.WarnFormat("TIMEOUT, Resent #{0} Type: {2} (0x{2:x2}) for {1} ({3} > {4}) RTO {5}",
												deleted.Header.datagramSequenceNumber.IntValue(),
												player.Username,
												deleted.FirstMessageId,
												elapsedTime,
												datagramTimout,
												player.Rto);
										SendDatagram(session, (Datagram)data);
										Interlocked.Increment(ref ServerInfo.NumberOfResends);
									}, datagram);
								}
							}
						}
					}
				});
			}
			finally
			{
				if (_forceQuitTimer.ElapsedMilliseconds > 100)
				{
					Log.WarnFormat("Update took unexpected long time: {0}", _forceQuitTimer.ElapsedMilliseconds);
				}

				Monitor.Exit(_updateGlobalLock);
				_cleanerTimer.Change(10, Timeout.Infinite);
			}
		}

		private object _sendSync = new object();

		public void SendPackage(Player player, Package message, Reliability reliability = Reliability.Reliable)
		{
			if (message == null) return;

			PlayerNetworkSession session;
			if (_playerSessions.TryGetValue(player.EndPoint, out session))
			{
				foreach (var datagram in Datagram.CreateDatagrams(message, session.MtuSize, session))
				{
					SendDatagram(session, datagram);
				}

				TraceSend(message);

				message.PutPool();

				//Thread.Sleep(5); // Really important to slow down speed a bit
			}
		}

		private void SendDatagram(PlayerNetworkSession session, Datagram datagram)
		{
			if (datagram.MessageParts.Count == 0)
			{
				datagram.PutPool();
				Log.WarnFormat("Failed to resend #{0}", datagram.Header.datagramSequenceNumber.IntValue());
				return;
			}

			datagram.Header.datagramSequenceNumber = Interlocked.Increment(ref session.DatagramSequenceNumber);

			datagram.TransmissionCount++;

			byte[] data = datagram.Encode();

			datagram.Timer.Restart();

			if (!session.WaitingForAcksQueue.TryAdd(datagram.Header.datagramSequenceNumber.IntValue(), datagram))
			{
				Log.Warn(string.Format("Datagram sequence unexpectedly existed in the ACK/NAK queue already {0}", datagram.Header.datagramSequenceNumber.IntValue()));
			}
			//datagram.PutPool();

			lock (session.SyncRoot)
			{
				SendData(data, session.EndPoint);
			}
		}


		private void SendData(byte[] data, IPEndPoint targetEndPoint)
		{
			try
			{
				_listener.Send(data, data.Length, targetEndPoint); // Less thread-issues it seems

				Interlocked.Increment(ref ServerInfo.NumberOfPacketsOutPerSecond);
				Interlocked.Add(ref ServerInfo.TotalPacketSizeOut, data.Length);
			}
			catch (ObjectDisposedException e)
			{
			}
			catch (Exception e)
			{
				//if (_listener == null || _listener.Client != null) Log.Error(string.Format("Send data lenght: {0}", data.Length), e);
			}
		}

		private static void TraceReceive(Package message, int refNumber = 0)
		{
			if (!Log.IsDebugEnabled) return;
			//if (!Debugger.IsAttached) return;

			Log.DebugFormat("> Receive: {0}: {1} (0x{0:x2}) #{2}", message.Id, message.GetType().Name, refNumber);
		}

		private static void TraceSend(Package message)
		{
			if (!Log.IsDebugEnabled) return;
			//if (!Debugger.IsAttached) return;

			Log.DebugFormat("<    Send: {0}: {1} (0x{0:x2})", message.Id, message.GetType().Name);
		}
	}
}